{"componentChunkName":"component---src-templates-post-tsx","path":"/react-component-lifecycle/","result":{"data":{"site":{"siteMetadata":{"title":"Qhan"}},"markdownRemark":{"id":"68502b3a-c30f-5e80-abcf-1a5512901207","excerpt":"装载(首次实例化) constructor() static getDerivedStateFromProps() render() componentDidMount() 更新(组件已存在时的状态改变) static getDerivedStateFromProps() shouldComponentUpdate…","html":"<ul>\n<li>装载<small>(首次实例化)</small>\n<ul>\n<li><a href=\"#constructor\">constructor()</a></li>\n<li><a href=\"#getDerivedStateFromProps\">static getDerivedStateFromProps()</a></li>\n<li><a href=\"#render\">render()</a></li>\n<li><a href=\"#componentDidMount\">componentDidMount()</a></li>\n</ul>\n</li>\n<li>更新<small>(组件已存在时的状态改变)</small>\n<ul>\n<li><a href=\"#getDerivedStateFromProps\">static getDerivedStateFromProps()</a></li>\n<li><a href=\"#shouldComponentUpdate\">shouldComponentUpdate()</a></li>\n<li><a href=\"#render\">render()</a></li>\n<li><a href=\"#getSnapshotBeforeUpdate\">getSnapshotBeforeUpdate()</a></li>\n<li><a href=\"#componentDidUpdate\">componentDidUpdate()</a></li>\n</ul>\n</li>\n<li>销毁<small>(清理期)</small>\n<ul>\n<li><a href=\"#componentWillUnmount\">componentWillUnmount()</a></li>\n</ul>\n</li>\n<li>错误\n<ul>\n<li><a href=\"#componentDidCatch\">componentDidCatch()</a></li>\n</ul>\n</li>\n<li>其它\n<ul>\n<li><a href=\"#setState\">setState()</a></li>\n<li><a href=\"#forceUpdate\">forceUpdate()</a></li>\n</ul>\n</li>\n<li>类属性\n<ul>\n<li><a href=\"#defaultProps\">defaultProps</a></li>\n<li><a href=\"#displayName\">displayName</a></li>\n</ul>\n</li>\n<li>实例属性\n<ul>\n<li><a href=\"#props\">props</a></li>\n<li><a href=\"#state\">state</a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"constructor\">constructor()</h3>\n<p><strong>如果不初始化状态与绑定方法，则不需要为你的组件实现构造函数</strong></p>\n<p>通常在 React 构造函数中只用于两个目的：</p>\n<ul>\n<li>初始化本地状态，并赋值到<code class=\"language-text\">this.state</code></li>\n<li>绑定事件处理程序到方法实例</li>\n</ul>\n<p><strong>不能在<code class=\"language-text\">constructor</code>中调用 setState()</strong>, 如果你的组件需要用到本地状态， 在构造函数中直接将初始状态赋值到 this.state</p>\n<p>避免在构造函数中引入任何副作用或订阅。对于这些用例，使用 componentDidMount()代替。</p>\n<p>提示</p>\n<p>避免将 props 复制到 state！这是一个常见和错误：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">   <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token comment\">// Don't do this</span>\n     <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token literal-property property\">color</span><span class=\"token operator\">:</span> props<span class=\"token punctuation\">.</span>color<span class=\"token punctuation\">}</span>\n   <span class=\"token punctuation\">}</span></code></pre></div>\n<p>这样做完全没有必要（你可以用<code class=\"language-text\">this.props.color</code>来替代），并且会引起组件创建的缺陷（在<code class=\"language-text\">color</code>更新时不能及时反应到状态上）\n如果你故意想忽略 prop 更新，那么可以采用此模式</p>\n<hr>\n<h3 id=\"getDerivedStateFromProps\">static getDerivedStateFromProps()</h3>\n<p>在调用呈现方法之前，在初始挂载和后续更新中调用该方法。它应该返回一个要更新状态的对象，或者返回 null 不更新任何内容。</p>\n<hr>\n<h3 id=\"render\">render()</h3>\n<p>该方法是类组件中唯一必需的方法。</p>\n<p>当调用时，它会检测<code class=\"language-text\">this.props</code>和<code class=\"language-text\">this.state</code>,并且返回一个以下的类型：</p>\n<ul>\n<li><strong>React 元素</strong>：通常为 JSX</li>\n<li><strong>数组或 fragment</strong>：让你一次渲染多个节点。<a href=\"https://reactjs.org/docs/fragments.html\">详细介绍</a></li>\n<li><strong>Portals</strong>： 让你在不同的节点渲染子元素。<a href=\"https://reactjs.org/docs/portals.html\">详细介绍</a></li>\n<li><strong>字符串或数字</strong>： 渲染文本节点</li>\n<li><strong>布尔值或 null</strong>： 什么都不渲染</li>\n</ul>\n<p>并且具有以下规则</p>\n<ul>\n<li>只能通过 this.props 和 this.state 访问数据</li>\n<li>只能出现一个顶级组件</li>\n<li>不能改变组件的状态</li>\n<li>不能修改 DOM 的输出</li>\n</ul>\n<hr>\n<h3 id=\"componentDidMount\">componentDidMount()</h3>\n<p>真实的 DOM 被渲染出来后调用，在该方法中可通过 this.getDOMNode()访问到真实的 DOM 元素。此时已可以使用其他类库来操作这个 DOM。</p>\n<p>在服务端中，该方法不会被调用。</p>\n<hr>\n<h3 id=\"shouldComponentUpdate\">shouldComponentUpdate()</h3>\n<p>组件是否应当渲染新的 props 或 state，返回 false 表示跳过后续的生命周期方法，通常不需要使用以避免出现 bug。在出现应用的瓶颈时，可通过该方法进行适当的优化。</p>\n<p>在首次渲染期间或者调用了 forceUpdate 方法后，该方法不会被调用</p>\n<hr>\n<h3 id=\"getSnapshotBeforeUpdate\">getSnapshotBeforeUpdate()</h3>\n<p>getSnapshotBeforeUpdate</p>\n<hr>\n<h3 id=\"componentDidUpdate\">componentDidUpdate()</h3>\n<p>完成渲染新的 props 或者 state 后调用，此时可以访问到新的 DOM 元素。</p>\n<hr>\n<h3 id=\"componentWillUnmount\">componentWillUnmount()</h3>\n<p>组件被移除之前被调用，可以用于做一些清理工作，在 componentDidMount 方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。</p>\n<hr>\n<h3 id=\"componentDidCatch\">componentDidCatch()</h3>\n<p>错误边界是指在子组件树的任何地方捕获 JavaScript 错误的响应组件，记录这些错误，并显示回退的 UI，而不是崩溃的组件树。错误边界在呈现期间、在生命周期方法中以及在它们下面的整个树的构造函数中捕获错误。</p>\n<p>如果一个类组件定义了这个生命周期方法，它将成为一个错误边界。在其中调用 setState()可以在下面的树中捕获未处理的 JavaScript 错误并显示回退 UI。仅使用错误边界从意外异常中恢复;不要试图将它们用于控制流。</p>\n<hr>\n<h3 id=\"setState\">setState</h3>\n<p>setState</p>\n<hr>\n<h3 id=\"forceUpdate\">forceUpdate</h3>\n<p>forceUpdate</p>\n<hr>\n<h3 id=\"defaultProps\">defaultProps</h3>\n<p>作用于组件类，只调用一次，返回对象用于设置默认的 props，对于引用值，会在实例中共享。</p>\n<hr>\n<h3 id=\"displayName\">displayName</h3>\n<p>displayName 字符串用于调试消息。通常，您不需要显式地设置它，因为它是从定义组件的函数或类的名称中推断出来的。如果您希望为调试目的显示不同的名称，或者当您创建高阶组件时，您可能希望显式地设置它，请参阅包装显示名称，以便进行详细的调试。</p>\n<hr>\n<h3 id=\"props\">props</h3>\n<p>props</p>\n<hr>\n<h3 id=\"state\">state</h3>\n<p>状态包含特定于此组件的数据，这些数据可能随时间而改变。状态是用户定义的，它应该是一个普通的 JavaScript 对象。</p>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://reactjs.org/docs/react-component.html\" title=\"React官方文档\">官方文档</a></li>\n<li><a href=\"http://react-china.org/t/react/1740\" title=\"React组件生命周期过程说明\">React 组件生命周期过程说明</a></li>\n</ul>","frontmatter":{"title":"React 组件生命周期","date":"July 12, 2018","description":null}},"previous":{"fields":{"slug":"/dnd-kit-ant-table/"},"frontmatter":{"title":"基于dnd-kit实现Antd Table组件拖拽排序"}},"next":{"fields":{"slug":"/cursor-position/"},"frontmatter":{"title":"文本域光标定位"}}},"pageContext":{"id":"68502b3a-c30f-5e80-abcf-1a5512901207","previousPostId":"1ff05058-4800-5266-b857-c22e505f84a5","nextPostId":"9ae37095-3590-5b6e-80b8-9f17f3cfc51d"}},"staticQueryHashes":["2841359383","3159585216"],"slicesMap":{}}